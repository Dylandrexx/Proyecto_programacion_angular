import { ChangeDetectionStrategy, Component, ContentChild, Directive, NgZone, TemplateRef, inject, input, signal, } from '@angular/core';
import { fromEvent, merge, Subscription } from 'rxjs';
import { filter, startWith, switchMap } from 'rxjs/operators';
import { MapService } from '../map/map.service';
import { MarkerComponent } from '../marker/marker.component';
import { LayerComponent } from '../layer/layer.component';
import { NgTemplateOutlet } from '@angular/common';
import * as i0 from "@angular/core";
export class PointDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: PointDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.3", type: PointDirective, isStandalone: true, selector: "ng-template[mglPoint]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: PointDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ng-template[mglPoint]',
                }]
        }] });
export class ClusterPointDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: ClusterPointDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.3", type: ClusterPointDirective, isStandalone: true, selector: "ng-template[mglClusterPoint]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: ClusterPointDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ng-template[mglClusterPoint]',
                }]
        }] });
let uniqId = 0;
export class MarkersForClustersComponent {
    mapService = inject(MapService);
    zone = inject(NgZone);
    /* Init input */
    source = input.required();
    /* Dynamic input */
    customPointIdKey = input();
    pointTpl;
    clusterPointTpl;
    clusterPoints = signal([]);
    layerId = `mgl-markers-for-clusters-${uniqId++}`;
    sub = new Subscription();
    ngAfterContentInit() {
        const clusterDataUpdate = () => fromEvent(this.mapService.mapInstance, 'data').pipe(filter((e) => e.sourceId === this.source() &&
            e.sourceDataType !== 'metadata' &&
            this.mapService.mapInstance.isSourceLoaded(this.source())));
        const sub = this.mapService.mapCreated$
            .pipe(switchMap(clusterDataUpdate), switchMap(() => merge(fromEvent(this.mapService.mapInstance, 'move'), fromEvent(this.mapService.mapInstance, 'moveend')).pipe(startWith(undefined))))
            .subscribe(() => {
            this.zone.run(() => {
                this.updateCluster();
            });
        });
        this.sub.add(sub);
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
    }
    trackByFeature(feature) {
        if (feature.id) {
            return feature.id;
        }
        const customPointIdKey = this.customPointIdKey();
        if (!customPointIdKey) {
            console.warn('[mgl-markers-for-clusters] feature.id is falsy, please provide a custom key');
            return '';
        }
        const id = feature.properties?.[customPointIdKey];
        if (!id) {
            console.warn(`[mgl-markers-for-clusters] Custom key [${customPointIdKey}], resolve to falsy for`, feature);
            return '';
        }
        return id;
    }
    updateCluster() {
        const params = {
            layers: [this.layerId],
        };
        if (!this.pointTpl) {
            params.filter = ['==', 'cluster', true];
        }
        const clusterPoints = this.mapService.mapInstance.queryRenderedFeatures(params);
        // Remove duplicates, because it seems that queryRenderedFeatures can return duplicates
        const seen = new Set();
        const unique = [];
        for (const feature of clusterPoints) {
            const id = this.trackByFeature(feature);
            if (!seen.has(id)) {
                seen.add(id);
                unique.push(feature);
            }
        }
        this.clusterPoints.set(unique);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: MarkersForClustersComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.0.3", type: MarkersForClustersComponent, isStandalone: true, selector: "mgl-markers-for-clusters", inputs: { source: { classPropertyName: "source", publicName: "source", isSignal: true, isRequired: true, transformFunction: null }, customPointIdKey: { classPropertyName: "customPointIdKey", publicName: "customPointIdKey", isSignal: true, isRequired: false, transformFunction: null } }, queries: [{ propertyName: "pointTpl", first: true, predicate: PointDirective, descendants: true, read: TemplateRef }, { propertyName: "clusterPointTpl", first: true, predicate: ClusterPointDirective, descendants: true, read: TemplateRef }], ngImport: i0, template: `
    <mgl-layer
      [id]="layerId"
      [source]="source()"
      type="circle"
      [paint]="{ 'circle-radius': 0 }"
    />
    @for (feature of clusterPoints(); track trackByFeature(feature)) {
      @if (feature.properties!['cluster']) {
        <mgl-marker [feature]="$any(feature)">
          @if (clusterPointTpl) {
            <ng-template
              [ngTemplateOutlet]="clusterPointTpl"
              [ngTemplateOutletContext]="{ $implicit: feature }"
            />
          }
        </mgl-marker>
      } @else {
        <mgl-marker [feature]="$any(feature)">
          @if (pointTpl) {
            <ng-template
              [ngTemplateOutlet]="pointTpl"
              [ngTemplateOutletContext]="{ $implicit: feature }"
            />
          }
        </mgl-marker>
      }
    }
  `, isInline: true, dependencies: [{ kind: "component", type: MarkerComponent, selector: "mgl-marker", inputs: ["offset", "anchor", "clickTolerance", "feature", "lngLat", "draggable", "popupShown", "className", "zIndex", "pitchAlignment", "rotationAlignment"], outputs: ["markerDragStart", "markerDragEnd", "markerDrag"] }, { kind: "component", type: LayerComponent, selector: "mgl-layer", inputs: ["id", "source", "type", "metadata", "sourceLayer", "filter", "layout", "paint", "before", "minzoom", "maxzoom"], outputs: ["layerClick", "layerDblClick", "layerMouseDown", "layerMouseUp", "layerMouseEnter", "layerMouseLeave", "layerMouseMove", "layerMouseOver", "layerMouseOut", "layerContextMenu", "layerTouchStart", "layerTouchEnd", "layerTouchCancel"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: MarkersForClustersComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'mgl-markers-for-clusters',
                    template: `
    <mgl-layer
      [id]="layerId"
      [source]="source()"
      type="circle"
      [paint]="{ 'circle-radius': 0 }"
    />
    @for (feature of clusterPoints(); track trackByFeature(feature)) {
      @if (feature.properties!['cluster']) {
        <mgl-marker [feature]="$any(feature)">
          @if (clusterPointTpl) {
            <ng-template
              [ngTemplateOutlet]="clusterPointTpl"
              [ngTemplateOutletContext]="{ $implicit: feature }"
            />
          }
        </mgl-marker>
      } @else {
        <mgl-marker [feature]="$any(feature)">
          @if (pointTpl) {
            <ng-template
              [ngTemplateOutlet]="pointTpl"
              [ngTemplateOutletContext]="{ $implicit: feature }"
            />
          }
        </mgl-marker>
      }
    }
  `,
                    imports: [MarkerComponent, LayerComponent, NgTemplateOutlet],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { pointTpl: [{
                type: ContentChild,
                args: [PointDirective, { read: TemplateRef, static: false }]
            }], clusterPointTpl: [{
                type: ContentChild,
                args: [ClusterPointDirective, { read: TemplateRef, static: false }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFya2Vycy1mb3ItY2x1c3RlcnMuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9uZ3gtbWFwYm94LWdsL3NyYy9saWIvbWFya2Vycy1mb3ItY2x1c3RlcnMvbWFya2Vycy1mb3ItY2x1c3RlcnMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFlBQVksRUFDWixTQUFTLEVBQ1QsTUFBTSxFQUVOLFdBQVcsRUFDWCxNQUFNLEVBQ04sS0FBSyxFQUNMLE1BQU0sR0FDUCxNQUFNLGVBQWUsQ0FBQztBQU12QixPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDOUQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUM3RCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDMUQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7O0FBS25ELE1BQU0sT0FBTyxjQUFjO3VHQUFkLGNBQWM7MkZBQWQsY0FBYzs7MkZBQWQsY0FBYztrQkFIMUIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsdUJBQXVCO2lCQUNsQzs7QUFNRCxNQUFNLE9BQU8scUJBQXFCO3VHQUFyQixxQkFBcUI7MkZBQXJCLHFCQUFxQjs7MkZBQXJCLHFCQUFxQjtrQkFIakMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsOEJBQThCO2lCQUN6Qzs7QUFHRCxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFxQ2YsTUFBTSxPQUFPLDJCQUEy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TUFBTTtpQkFDaEQ7OEJBY0MsUUFBUTtzQkFEUCxZQUFZO3VCQUFDLGNBQWMsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRTtnQkFHbEUsZUFBZTtzQkFEZCxZQUFZO3VCQUFDLHFCQUFxQixFQUFFLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBEaXJlY3RpdmUsXG4gIE5nWm9uZSxcbiAgT25EZXN0cm95LFxuICBUZW1wbGF0ZVJlZixcbiAgaW5qZWN0LFxuICBpbnB1dCxcbiAgc2lnbmFsLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB0eXBlIHtcbiAgTWFwU291cmNlRGF0YUV2ZW50LFxuICBHZW9KU09ORmVhdHVyZSxcbiAgRmlsdGVyU3BlY2lmaWNhdGlvbixcbn0gZnJvbSAnbWFwYm94LWdsJztcbmltcG9ydCB7IGZyb21FdmVudCwgbWVyZ2UsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCBzdGFydFdpdGgsIHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAvbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFya2VyQ29tcG9uZW50IH0gZnJvbSAnLi4vbWFya2VyL21hcmtlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgTGF5ZXJDb21wb25lbnQgfSBmcm9tICcuLi9sYXllci9sYXllci5jb21wb25lbnQnO1xuaW1wb3J0IHsgTmdUZW1wbGF0ZU91dGxldCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ25nLXRlbXBsYXRlW21nbFBvaW50XScsXG59KVxuZXhwb3J0IGNsYXNzIFBvaW50RGlyZWN0aXZlIHt9XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ25nLXRlbXBsYXRlW21nbENsdXN0ZXJQb2ludF0nLFxufSlcbmV4cG9ydCBjbGFzcyBDbHVzdGVyUG9pbnREaXJlY3RpdmUge31cblxubGV0IHVuaXFJZCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ21nbC1tYXJrZXJzLWZvci1jbHVzdGVycycsXG5cbiAgdGVtcGxhdGU6IGBcbiAgICA8bWdsLWxheWVyXG4gICAgICBbaWRdPVwibGF5ZXJJZFwiXG4gICAgICBbc291cmNlXT1cInNvdXJjZSgpXCJcbiAgICAgIHR5cGU9XCJjaXJjbGVcIlxuICAgICAgW3BhaW50XT1cInsgJ2NpcmNsZS1yYWRpdXMnOiAwIH1cIlxuICAgIC8+XG4gICAgQGZvciAoZmVhdHVyZSBvZiBjbHVzdGVyUG9pbnRzKCk7IHRyYWNrIHRyYWNrQnlGZWF0dXJlKGZlYXR1cmUpKSB7XG4gICAgICBAaWYgKGZlYXR1cmUucHJvcGVydGllcyFbJ2NsdXN0ZXInXSkge1xuICAgICAgICA8bWdsLW1hcmtlciBbZmVhdHVyZV09XCIkYW55KGZlYXR1cmUpXCI+XG4gICAgICAgICAgQGlmIChjbHVzdGVyUG9pbnRUcGwpIHtcbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJjbHVzdGVyUG9pbnRUcGxcIlxuICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyAkaW1wbGljaXQ6IGZlYXR1cmUgfVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgIH1cbiAgICAgICAgPC9tZ2wtbWFya2VyPlxuICAgICAgfSBAZWxzZSB7XG4gICAgICAgIDxtZ2wtbWFya2VyIFtmZWF0dXJlXT1cIiRhbnkoZmVhdHVyZSlcIj5cbiAgICAgICAgICBAaWYgKHBvaW50VHBsKSB7XG4gICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwicG9pbnRUcGxcIlxuICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyAkaW1wbGljaXQ6IGZlYXR1cmUgfVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgIH1cbiAgICAgICAgPC9tZ2wtbWFya2VyPlxuICAgICAgfVxuICAgIH1cbiAgYCxcbiAgaW1wb3J0czogW01hcmtlckNvbXBvbmVudCwgTGF5ZXJDb21wb25lbnQsIE5nVGVtcGxhdGVPdXRsZXRdLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgTWFya2Vyc0ZvckNsdXN0ZXJzQ29tcG9uZW50XG4gIGltcGxlbWVudHMgT25EZXN0cm95LCBBZnRlckNvbnRlbnRJbml0XG57XG4gIHByaXZhdGUgbWFwU2VydmljZSA9IGluamVjdChNYXBTZXJ2aWNlKTtcbiAgcHJpdmF0ZSB6b25lID0gaW5qZWN0KE5nWm9uZSk7XG5cbiAgLyogSW5pdCBpbnB1dCAqL1xuICBzb3VyY2UgPSBpbnB1dC5yZXF1aXJlZDxzdHJpbmc+KCk7XG5cbiAgLyogRHluYW1pYyBpbnB1dCAqL1xuICBjdXN0b21Qb2ludElkS2V5ID0gaW5wdXQ8c3RyaW5nPigpO1xuXG4gIEBDb250ZW50Q2hpbGQoUG9pbnREaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogZmFsc2UgfSlcbiAgcG9pbnRUcGw/OiBUZW1wbGF0ZVJlZjx1bmtub3duPjtcbiAgQENvbnRlbnRDaGlsZChDbHVzdGVyUG9pbnREaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogZmFsc2UgfSlcbiAgY2x1c3RlclBvaW50VHBsOiBUZW1wbGF0ZVJlZjx1bmtub3duPjtcblxuICBjbHVzdGVyUG9pbnRzID0gc2lnbmFsPEdlb0pTT05GZWF0dXJlW10+KFtdKTtcbiAgbGF5ZXJJZCA9IGBtZ2wtbWFya2Vycy1mb3ItY2x1c3RlcnMtJHt1bmlxSWQrK31gO1xuXG4gIHByaXZhdGUgc3ViID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBjb25zdCBjbHVzdGVyRGF0YVVwZGF0ZSA9ICgpID0+XG4gICAgICBmcm9tRXZlbnQ8TWFwU291cmNlRGF0YUV2ZW50Pih0aGlzLm1hcFNlcnZpY2UubWFwSW5zdGFuY2UsICdkYXRhJykucGlwZShcbiAgICAgICAgZmlsdGVyKFxuICAgICAgICAgIChlKSA9PlxuICAgICAgICAgICAgZS5zb3VyY2VJZCA9PT0gdGhpcy5zb3VyY2UoKSAmJlxuICAgICAgICAgICAgZS5zb3VyY2VEYXRhVHlwZSAhPT0gJ21ldGFkYXRhJyAmJlxuICAgICAgICAgICAgdGhpcy5tYXBTZXJ2aWNlLm1hcEluc3RhbmNlLmlzU291cmNlTG9hZGVkKHRoaXMuc291cmNlKCkpLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICBjb25zdCBzdWIgPSB0aGlzLm1hcFNlcnZpY2UubWFwQ3JlYXRlZCRcbiAgICAgIC5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAoY2x1c3RlckRhdGFVcGRhdGUpLFxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT5cbiAgICAgICAgICBtZXJnZShcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLm1hcFNlcnZpY2UubWFwSW5zdGFuY2UsICdtb3ZlJyksXG4gICAgICAgICAgICBmcm9tRXZlbnQodGhpcy5tYXBTZXJ2aWNlLm1hcEluc3RhbmNlLCAnbW92ZWVuZCcpLFxuICAgICAgICAgICkucGlwZShzdGFydFdpdGgodW5kZWZpbmVkKSksXG4gICAgICAgICksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgdGhpcy51cGRhdGVDbHVzdGVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgdGhpcy5zdWIuYWRkKHN1Yik7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1Yi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgdHJhY2tCeUZlYXR1cmUoZmVhdHVyZTogR2VvSlNPTkZlYXR1cmUpIHtcbiAgICBpZiAoZmVhdHVyZS5pZCkge1xuICAgICAgcmV0dXJuIGZlYXR1cmUuaWQ7XG4gICAgfVxuICAgIGNvbnN0IGN1c3RvbVBvaW50SWRLZXkgPSB0aGlzLmN1c3RvbVBvaW50SWRLZXkoKTtcbiAgICBpZiAoIWN1c3RvbVBvaW50SWRLZXkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1ttZ2wtbWFya2Vycy1mb3ItY2x1c3RlcnNdIGZlYXR1cmUuaWQgaXMgZmFsc3ksIHBsZWFzZSBwcm92aWRlIGEgY3VzdG9tIGtleScsXG4gICAgICApO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGZlYXR1cmUucHJvcGVydGllcz8uW2N1c3RvbVBvaW50SWRLZXldO1xuICAgIGlmICghaWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFttZ2wtbWFya2Vycy1mb3ItY2x1c3RlcnNdIEN1c3RvbSBrZXkgWyR7Y3VzdG9tUG9pbnRJZEtleX1dLCByZXNvbHZlIHRvIGZhbHN5IGZvcmAsXG4gICAgICAgIGZlYXR1cmUsXG4gICAgICApO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUNsdXN0ZXIoKSB7XG4gICAgY29uc3QgcGFyYW1zOiB7IGxheWVycz86IHN0cmluZ1tdOyBmaWx0ZXI/OiBGaWx0ZXJTcGVjaWZpY2F0aW9uIH0gPSB7XG4gICAgICBsYXllcnM6IFt0aGlzLmxheWVySWRdLFxuICAgIH07XG4gICAgaWYgKCF0aGlzLnBvaW50VHBsKSB7XG4gICAgICBwYXJhbXMuZmlsdGVyID0gWyc9PScsICdjbHVzdGVyJywgdHJ1ZV07XG4gICAgfVxuICAgIGNvbnN0IGNsdXN0ZXJQb2ludHMgPVxuICAgICAgdGhpcy5tYXBTZXJ2aWNlLm1hcEluc3RhbmNlLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhwYXJhbXMpO1xuICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVzLCBiZWNhdXNlIGl0IHNlZW1zIHRoYXQgcXVlcnlSZW5kZXJlZEZlYXR1cmVzIGNhbiByZXR1cm4gZHVwbGljYXRlc1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdW5pcXVlID0gW107XG4gICAgZm9yIChjb25zdCBmZWF0dXJlIG9mIGNsdXN0ZXJQb2ludHMpIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy50cmFja0J5RmVhdHVyZShmZWF0dXJlKTtcbiAgICAgIGlmICghc2Vlbi5oYXMoaWQpKSB7XG4gICAgICAgIHNlZW4uYWRkKGlkKTtcbiAgICAgICAgdW5pcXVlLnB1c2goZmVhdHVyZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2x1c3RlclBvaW50cy5zZXQodW5pcXVlKTtcbiAgfVxufVxuIl19